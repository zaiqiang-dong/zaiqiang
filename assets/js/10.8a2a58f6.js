(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{218:function(s,t,a){"use strict";a.r(t);var e=a(0),n=Object(e.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("p",[a("em",[s._v("理想很丰满，现实很骨感，你的程序也一样，不一定会按照你的预期走")])]),s._v(" "),a("h2",{attrs:{id:"_1-什么是内存屏障"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是内存屏障","aria-hidden":"true"}},[s._v("#")]),s._v(" 1.什么是内存屏障")]),s._v(" "),a("p",[s._v("是确保某些指令一定要在另外一些指令之前执行的一种机制，本质上讲是一条指令。")]),s._v(" "),a("blockquote",[a("p",[s._v("从软件的角度讲内存屏障和内存没有什么直接的关系，它仅仅是叫内存屏障。")])]),s._v(" "),a("h2",{attrs:{id:"_2-为什么需要内存屏障"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-为什么需要内存屏障","aria-hidden":"true"}},[s._v("#")]),s._v(" 2.为什么需要内存屏障")]),s._v(" "),a("p",[s._v("主要是为了解决指令顺序一致性问题。")]),s._v(" "),a("h3",{attrs:{id:"_2-1-什么是顺序一致性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-什么是顺序一致性","aria-hidden":"true"}},[s._v("#")]),s._v(" 2.1 什么是顺序一致性")]),s._v(" "),a("p",[s._v("软件的顺序分为两种")]),s._v(" "),a("ol",[a("li",[s._v("软件编写时顺序")]),s._v(" "),a("li",[s._v("软件执行时顺序")])]),s._v(" "),a("p",[s._v("所谓顺序一致就是指软件的两种顺序要一致，也就是程序的执行和程序编写者的预期是一致的。")]),s._v(" "),a("h3",{attrs:{id:"_2-2-为什么会不一致"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-为什么会不一致","aria-hidden":"true"}},[s._v("#")]),s._v(" 2.2 为什么会不一致")]),s._v(" "),a("p",[s._v("原因主要是如下三个：")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("编译器原因")]),s._v(" "),a("p",[s._v("编译器在编译时，会对代码进行编译优化，从而提高代码执行效率，这个时候就可能会改变代码的执行顺序。也就是所谓的基于依赖的优化。")])]),s._v(" "),a("li",[a("p",[s._v("代码乱序执行")]),s._v(" "),a("p",[s._v("现代CPU多具备多发射，乱序执行等功能，主要是提高效率，但这必然会有一致性的问题产生。")])]),s._v(" "),a("li",[a("p",[s._v("多处理器同步")]),s._v(" "),a("p",[s._v("在多CPU的系统中，当一个CPU在进行读写操作时，可能有其他的CPU会进行读写操作，就可能会出现不一致的问题。")])])]),s._v(" "),a("h2",{attrs:{id:"_3-通过内存屏障来解决一致性问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-通过内存屏障来解决一致性问题","aria-hidden":"true"}},[s._v("#")]),s._v(" 3.通过内存屏障来解决一致性问题")]),s._v(" "),a("p",[s._v("内存屏障简单来讲就是一条CPU指令，每个平台上实现不一样，在ARM架构实现如下：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('#define isb()\t\tasm volatile("isb" : : : "memory")\n#define dmb(opt)\tasm volatile("dmb " #opt : : : "memory")\n#define dsb(opt)\tasm volatile("dsb " #opt : : : "memory")\n\n#define mb()\t\tdsb(sy)\n#define rmb()\t\tdsb(ld)\n#define wmb()\t\tdsb(st)\n\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("p",[s._v("如何使用，通过伪代码来展示")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("foo(){\n\tInstruction-1;\n\tmb();\n    Instruction-2\n}\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("p",[s._v("在上面的伪代码中，可以确保Instruction-2在Instruction-1之后执行。")]),s._v(" "),a("h2",{attrs:{id:"_4-缓存一致性是否需要内存屏障来解决"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-缓存一致性是否需要内存屏障来解决","aria-hidden":"true"}},[s._v("#")]),s._v(" 4.缓存一致性是否需要内存屏障来解决")]),s._v(" "),a("p",[s._v("缓存一致性是指多CPU系统中，一个CPU对某个地址内容修改过后，要保证另外一个CPU访问这个地址后，拿到的值是最新的。\n但是这个需要内存一致性来解决吗？答案是不需要，这个是由硬件通过协议来完成的，不需要软件的任何参于。")])])}),[],!1,null,null,null);t.default=n.exports}}]);