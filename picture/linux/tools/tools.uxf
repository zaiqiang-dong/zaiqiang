<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<diagram program="umlet" version="14.3.0">
  <zoom_level>8</zoom_level>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>9240</x>
      <y>552</y>
      <w>320</w>
      <h>640</h>
    </coordinates>
    <panel_attributes>
*struct  trace_array*
--

struct list_head       list_head
struct list_head       list
char *                 name
struct trace_buffer    trace_buffer
struct trace_buffer    trace_buffer
struct trace_pid_list  trace_pid_list
struct trace_pid_list  __rcu
int                    max_lock
int                    buffer_disabled
int                    stop_count
int                    clock_id
int                    nr_topts
struct tracer          tracer
struct tracer *        current_trace
unsigned int           trace_flags
unsigned char          trace_flags_index
unsigned int           flags
int                    start_lock
struct dentry          dentry
struct dentry *        dir
struct dentry *        options
struct dentry *        percpu_dir
struct dentry *        event_dir
struct trace_options   trace_options
struct trace_options * topts
struct list_head       systems

**struct list_head       events**

int                    tracing_cpumask
int                    ref




struct ftrace_ops      ftrace_ops


struct ftrace_ops *    ops
struct trace_pid_list	__rcu *function_pids;

struct list_head  func_probes;

struct list_head  mod_trace;
struct list_head  mod_notrace;

int                    function_enabled

</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>9816</x>
      <y>624</y>
      <w>320</w>
      <h>160</h>
    </coordinates>
    <panel_attributes>
*struct trace_buffer trace_buffer*
--

struct trace_array *   tr
struct ring_buffer     ring_buffer
struct ring_buffer *   buffer
struct trace_array_cpu trace_array_cpu
struct trace_array_cpu __percpu
int                    time_start
int                    cpu

</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>9224</x>
      <y>1288</y>
      <w>320</w>
      <h>272</h>
    </coordinates>
    <panel_attributes>
*struct ring_buffer ring_buffer*
--

unsigned int                  flags
int                           cpus
int                           record_disabled
int                           resize_disabled
int                           cpumask
struct lock_class_key         lock_class_key
struct lock_class_key *       reader_lock_key
struct mutex                  mutex
struct mutex                  mutex
struct ring_buffer_per_cpu    ring_buffer_per_cpu
struct ring_buffer_per_cpu ** buffers
struct notifier_block         notifier_block
struct notifier_block         cpu_notify
int ((int *))(void)           u64
struct rb_irq_work            rb_irq_work
struct rb_irq_work            irq_work

</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>9784</x>
      <y>1544</y>
      <w>320</w>
      <h>488</h>
    </coordinates>
    <panel_attributes>
*struct ring_buffer_per_cpu ring_buffer_per_cpu*
--

int                   cpu
int                   record_disabled
struct ring_buffer *  buffer
int                   reader_lock
int                   lock
struct lock_class_key lock_key
unsigned long         nr_pages
unsigned int          current_context
struct list_head *    pages
struct buffer_page    buffer_page
struct buffer_page *  head_page
struct buffer_page *  tail_page
struct buffer_page *  commit_page
struct buffer_page *  reader_page
unsigned long         lost_events
unsigned long         last_overrun
int                   entries_bytes
int                   entries
int                   overrun
int                   commit_overrun
int                   dropped_events
int                   committing
int                   commits
unsigned long         read
unsigned long         read_bytes
int                   write_stamp
int                   read_stamp
long                  nr_pages_to_update
struct list_head      new_pages
struct work_struct    work_struct
struct work_struct    update_pages_work
struct completion     completion
struct completion     update_done
struct rb_irq_work    irq_work

</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>9792</x>
      <y>1392</y>
      <w>256</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>struct ring_buffer_per_cpu[NR_CPU]</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>9536</x>
      <y>1392</y>
      <w>272</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>9912</x>
      <y>1408</y>
      <w>24</w>
      <h>152</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;170.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>10352</x>
      <y>1896</y>
      <w>320</w>
      <h>280</h>
    </coordinates>
    <panel_attributes>struct ring_buffer 
--
	unsigned			flags;
	int				cpus;
	atomic_t			record_disabled;
	atomic_t			resize_disabled;
	cpumask_var_t			cpumask;

	struct lock_class_key		*reader_lock_key;

	struct mutex			mutex;

	struct ring_buffer_per_cpu	**buffers;

#ifdef CONFIG_HOTPLUG_CPU
	struct notifier_block		cpu_notify;
#endif
	u64				(*clock)(void);

	struct rb_irq_work		irq_work;

</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>10088</x>
      <y>1896</y>
      <w>280</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>10368</x>
      <y>1488</y>
      <w>208</w>
      <h>120</h>
    </coordinates>
    <panel_attributes>struct work_struct
--
	atomic_long_t data;
	struct list_head entry;
	work_func_t func;
#ifdef CONFIG_LOCKDEP
	struct lockdep_map lockdep_map;
#endif
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>10096</x>
      <y>1488</y>
      <w>288</w>
      <h>144</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;160.0;170.0;160.0;170.0;10.0;340.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>10368</x>
      <y>1720</y>
      <w>248</w>
      <h>120</h>
    </coordinates>
    <panel_attributes>struct rb_irq_work
--
	struct irq_work			work;
	wait_queue_head_t		waiters;
	wait_queue_head_t		full_waiters;
	bool				waiters_pending;
	bool				full_waiters_pending;
	bool				wakeup_full;

</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>10096</x>
      <y>1720</y>
      <w>288</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>10488</x>
      <y>1832</y>
      <w>24</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;80.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>8768</x>
      <y>1296</y>
      <w>336</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>static struct ring_buffer *temp_buffer;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>9096</x>
      <y>1296</y>
      <w>144</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>8768</x>
      <y>560</y>
      <w>240</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>static struct trace_array	global_trace;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>9000</x>
      <y>560</y>
      <w>256</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>9392</x>
      <y>1184</y>
      <w>24</w>
      <h>120</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>9552</x>
      <y>624</y>
      <w>280</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>9840</x>
      <y>0</y>
      <w>304</w>
      <h>560</h>
    </coordinates>
    <panel_attributes>struct tracer
--
	const char		*name;
	int			(*init)(struct trace_array *tr);
	void			(*reset)(struct trace_array *tr);
	void			(*start)(struct trace_array *tr);
	void			(*stop)(struct trace_array *tr);
	int			(*update_thresh)(struct trace_array *tr);
	void			(*open)(struct trace_iterator *iter);
	void			(*pipe_open)(struct trace_iterator *iter);
	void			(*close)(struct trace_iterator *iter);
	void			(*pipe_close)(struct trace_iterator *iter);
	ssize_t			(*read)(struct trace_iterator *iter,
					struct file *filp, char __user *ubuf,
					size_t cnt, loff_t *ppos);
	ssize_t			(*splice_read)(struct trace_iterator *iter,
					       struct file *filp,
					       loff_t *ppos,
					       struct pipe_inode_info *pipe,
					       size_t len,
					       unsigned int flags);
#ifdef CONFIG_FTRACE_STARTUP_TEST
	int			(*selftest)(struct tracer *trace,
					    struct trace_array *tr);
#endif
	void			(*print_header)(struct seq_file *m);
	enum print_line_t	(*print_line)(struct trace_iterator *iter);
	/* If you handled the flag setting, return 0 */
	int			(*set_flag)(struct trace_array *tr,
					    u32 old_flags, u32 bit, int set);
	/* Return 0 if OK with change, else return non-zero */
	int			(*flag_changed)(struct trace_array *tr,
						u32 mask, int set);
	struct tracer		*next;
	struct tracer_flags	*flags;
	int			enabled;
	int			ref;
	bool			print_max;
	bool			allow_instances;
#ifdef CONFIG_TRACER_MAX_TRACE
	bool			use_max_tr;
#endif

</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>9552</x>
      <y>0</y>
      <w>304</w>
      <h>624</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;760.0;240.0;760.0;240.0;10.0;360.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>10368</x>
      <y>2272</y>
      <w>320</w>
      <h>128</h>
    </coordinates>
    <panel_attributes>struct buffer_page
--
	struct list_head list;		/* list of buffer pages */
	local_t		 write;		/* index for next write */
	unsigned	 read;		/* index for next read */
	local_t		 entries;	/* entries on this page */
	unsigned long	 real_end;	/* real end of data */
	struct buffer_data_page *page;	/* Actual data page */
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>10096</x>
      <y>1992</y>
      <w>288</w>
      <h>304</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;10.0;160.0;360.0;340.0;360.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>11200</x>
      <y>2600</y>
      <w>352</w>
      <h>96</h>
    </coordinates>
    <panel_attributes>enum ring_buffer_type
--
	RINGBUF_TYPE_DATA_TYPE_LEN_MAX = 28,
	RINGBUF_TYPE_PADDING,
	RINGBUF_TYPE_TIME_EXTEND,
	/* FIXME: RINGBUF_TYPE_TIME_STAMP not implemented */
	RINGBUF_TYPE_TIME_STAMP,

</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>11544</x>
      <y>2472</y>
      <w>40</w>
      <h>160</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>30.0;10.0;30.0;180.0;10.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>7256</x>
      <y>2416</y>
      <w>296</w>
      <h>120</h>
    </coordinates>
    <panel_attributes>struct tracepoint
--
	const char *name;		/* Tracepoint name */
	struct static_key key;
	void (*regfunc)(void);
	void (*unregfunc)(void);
	struct tracepoint_func __rcu *funcs;

</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>7688</x>
      <y>2488</y>
      <w>208</w>
      <h>88</h>
    </coordinates>
    <panel_attributes>struct tracepoint_func
--
	void *func;
	void *data;
	int prio;
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7544</x>
      <y>2488</y>
      <w>160</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>6560</x>
      <y>2912</y>
      <w>336</w>
      <h>328</h>
    </coordinates>
    <panel_attributes>struct trace_event_class 
--
	const char		*system;

	
	void			*probe;

	
#ifdef CONFIG_PERF_EVENTS


	void			*perf_probe;

	
#endif
	int			(*reg)(struct trace_event_call *event,
				       enum trace_reg type, void *data);
	int			(*define_fields)(struct trace_event_call *);
	struct list_head	*(*get_fields)(struct trace_event_call *);
	struct list_head	fields;
	int			(*raw_init)(struct trace_event_call *);

</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>7240</x>
      <y>2744</y>
      <w>352</w>
      <h>464</h>
    </coordinates>
    <panel_attributes>struct trace_event_call
--
	struct list_head	list;
	struct trace_event_class *class;
	union {
		char			*name;
		/* Set TRACE_EVENT_FL_TRACEPOINT flag when using "tp" */
		struct tracepoint	*tp;
	};
	struct trace_event	event;
	char			*print_fmt;
	struct event_filter	*filter;
	void			*mod;
	void			*data;
	/*
	 *   bit 0:		filter_active
	 *   bit 1:		allow trace by non root (cap any)
	 *   bit 2:		failed to apply filter
	 *   bit 3:		trace internal event (do not enable)
	 *   bit 4:		Event was enabled by module
	 *   bit 5:		use call filter rather than file filter
	 *   bit 6:		Event is a tracepoint
	 */
	int			flags; /* static flags of different events */

#ifdef CONFIG_PERF_EVENTS
	int				perf_refcount;
	struct hlist_head __percpu	*perf_events;
	struct bpf_prog			*prog;
	struct perf_event		*bpf_prog_owner;

	int	(*perf_perm)(struct trace_event_call *,
			     struct perf_event *);
#endif

</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>6888</x>
      <y>2912</y>
      <w>368</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>440.0;10.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>7280</x>
      <y>2616</y>
      <w>192</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>LIST_HEAD(ftrace_events);
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7144</x>
      <y>2616</y>
      <w>152</w>
      <h>168</h>
    </coordinates>
    <panel_attributes>lt=&lt;-</panel_attributes>
    <additional_attributes>120.0;190.0;10.0;190.0;10.0;10.0;170.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7584</x>
      <y>2768</y>
      <w>112</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;-</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>7680</x>
      <y>2768</y>
      <w>288</w>
      <h>24</h>
    </coordinates>
    <panel_attributes> ...  struct trace_event_call ...</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7464</x>
      <y>2616</y>
      <w>592</w>
      <h>184</h>
    </coordinates>
    <panel_attributes>lt=&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;720.0;10.0;720.0;210.0;630.0;210.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7000</x>
      <y>2416</y>
      <w>272</w>
      <h>440</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>300.0;530.0;10.0;530.0;10.0;10.0;320.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>10904</x>
      <y>2360</y>
      <w>424</w>
      <h>72</h>
    </coordinates>
    <panel_attributes>struct buffer_data_page 
--
	u64		 time_stamp;	/* page time stamp */
	local_t		 commit;	/* write committed index */
	unsigned char	 data[] RB_ALIGN_DATA;	/* data of buffer page */
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>10680</x>
      <y>2360</y>
      <w>240</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>11456</x>
      <y>2408</y>
      <w>256</w>
      <h>72</h>
    </coordinates>
    <panel_attributes>struct ring_buffer_event
--
	u32		type_len:5, time_delta:27;

	u32		array[];
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>11320</x>
      <y>2408</y>
      <w>152</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>11800</x>
      <y>2456</y>
      <w>264</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>struct trace_entry 
--
	unsigned short		type;
	unsigned char		flags;
	unsigned char		preempt_count;
	int			pid;
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>11704</x>
      <y>2456</y>
      <w>112</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>7296</x>
      <y>384</y>
      <w>384</w>
      <h>592</h>
    </coordinates>
    <panel_attributes>struct tracer
--
	const char		*name;
	int			(*init)(struct trace_array *tr);
	void			(*reset)(struct trace_array *tr);
	void			(*start)(struct trace_array *tr);
	void			(*stop)(struct trace_array *tr);
	int			(*update_thresh)(struct trace_array *tr);
	void			(*open)(struct trace_iterator *iter);
	void			(*pipe_open)(struct trace_iterator *iter);
	void			(*close)(struct trace_iterator *iter);
	void			(*pipe_close)(struct trace_iterator *iter);
	ssize_t			(*read)(struct trace_iterator *iter,
					struct file *filp, char __user *ubuf,
					size_t cnt, loff_t *ppos);
	ssize_t			(*splice_read)(struct trace_iterator *iter,
					       struct file *filp,
					       loff_t *ppos,
					       struct pipe_inode_info *pipe,
					       size_t len,
					       unsigned int flags);
#ifdef CONFIG_FTRACE_STARTUP_TEST
	int			(*selftest)(struct tracer *trace,
					    struct trace_array *tr);
#endif
	void			(*print_header)(struct seq_file *m);
	enum print_line_t	(*print_line)(struct trace_iterator *iter);
	/* If you handled the flag setting, return 0 */
	int			(*set_flag)(struct trace_array *tr,
					    u32 old_flags, u32 bit, int set);
	/* Return 0 if OK with change, else return non-zero */
	int			(*flag_changed)(struct trace_array *tr,
						u32 mask, int set);
	struct tracer		*next;
	struct tracer_flags	*flags;
	int			enabled;
	int			ref;
	bool			print_max;
	bool			allow_instances;
#ifdef CONFIG_TRACER_MAX_TRACE
	bool			use_max_tr;
#endif
	/* True if tracer cannot be enabled in kernel param */
	bool			noboot;
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>6584</x>
      <y>376</y>
      <w>440</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>static struct tracer		*trace_types __read_mostly;
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7016</x>
      <y>384</y>
      <w>296</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;-</panel_attributes>
    <additional_attributes>350.0;10.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>7896</x>
      <y>800</y>
      <w>176</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>struct tracer function_trace
--</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7672</x>
      <y>800</y>
      <w>240</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;.</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>6808</x>
      <y>272</y>
      <w>1376</w>
      <h>576</h>
    </coordinates>
    <panel_attributes>lt=&lt;.</panel_attributes>
    <additional_attributes>10.0;130.0;10.0;20.0;1700.0;10.0;1700.0;700.0;1580.0;700.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>7736</x>
      <y>1824</y>
      <w>352</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>struct dyn_ftrace
--
	unsigned long		ip; /* address of mcount call-site */
	unsigned long		flags;
	struct dyn_arch_ftrace	arch;

</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>6736</x>
      <y>1264</y>
      <w>304</w>
      <h>232</h>
    </coordinates>
    <panel_attributes>struct ftrace_ops
--
	ftrace_func_t			func;
	struct ftrace_ops __rcu		*next;
	unsigned long			flags;
	void				*private;
	ftrace_func_t			saved_func;
	int __percpu			*disabled;
#ifdef CONFIG_DYNAMIC_FTRACE
	struct ftrace_ops_hash		local_hash;
	struct ftrace_ops_hash		*func_hash;
	struct ftrace_ops_hash		old_hash;
	unsigned long			trampoline;
	unsigned long			trampoline_size;
#endif
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>7104</x>
      <y>1624</y>
      <w>560</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>static struct ftrace_ops __rcu *ftrace_ops_list __read_mostly = &amp;ftrace_list_end;
lw=4</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>6648</x>
      <y>1624</y>
      <w>232</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>static struct ftrace_ops global_ops;
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>7248</x>
      <y>1384</y>
      <w>312</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>struct ftrace_ops_hash
--
	struct ftrace_hash __rcu	*notrace_hash;
	struct ftrace_hash __rcu	*filter_hash;
	struct mutex			regex_lock;

</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7032</x>
      <y>1392</y>
      <w>232</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>7696</x>
      <y>1400</y>
      <w>232</w>
      <h>96</h>
    </coordinates>
    <panel_attributes>struct ftrace_hash
--
	unsigned long		size_bits;
	struct hlist_head	*buckets;
	unsigned long		count;
	unsigned long		flags;
	struct rcu_head		rcu;

</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7552</x>
      <y>1400</y>
      <w>160</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7920</x>
      <y>1432</y>
      <w>120</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;-</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>7448</x>
      <y>1800</y>
      <w>208</w>
      <h>96</h>
    </coordinates>
    <panel_attributes>struct ftrace_page
--
	struct ftrace_page	*next;
	struct dyn_ftrace	*records;
	int			index;
	int			size;

</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>7304</x>
      <y>2040</y>
      <w>296</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>static struct ftrace_page	*ftrace_pages_start;
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>7616</x>
      <y>2040</y>
      <w>264</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>static struct ftrace_page	*ftrace_pages;
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7464</x>
      <y>1888</y>
      <w>24</w>
      <h>168</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;190.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7624</x>
      <y>1888</y>
      <w>24</w>
      <h>168</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;190.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7648</x>
      <y>1832</y>
      <w>104</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>8024</x>
      <y>1432</y>
      <w>208</w>
      <h>168</h>
    </coordinates>
    <panel_attributes>struct ftrace_func_entry[]
--
buckets[0]
-
buckets[1]
-
buckets[2]
-
.
.
.
-
buckets[n-2]
-
buckets[n-1]
-
buckets[n]
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>7200</x>
      <y>1264</y>
      <w>464</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>typedef void (*ftrace_func_t)(unsigned long ip, unsigned long parent_ip,
			      struct ftrace_ops *op, struct pt_regs *regs);
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7032</x>
      <y>1280</y>
      <w>184</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>7664</x>
      <y>3984</y>
      <w>256</w>
      <h>112</h>
    </coordinates>
    <panel_attributes>struct ftrace_func_command
--
	struct list_head	list;
	char			*name;
	int			(*func)(struct trace_array *tr,
					struct ftrace_hash *hash,
					char *func, char *cmd,
					char *params, int enable);
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>7176</x>
      <y>4064</y>
      <w>352</w>
      <h>64</h>
    </coordinates>
    <panel_attributes>static struct ftrace_func_command ftrace_traceoff_cmd
--
	.name			= "traceoff",
	.func			= ftrace_trace_onoff_callback,
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7520</x>
      <y>4072</y>
      <w>160</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>7176</x>
      <y>3984</y>
      <w>344</w>
      <h>56</h>
    </coordinates>
    <panel_attributes>static struct ftrace_func_command ftrace_traceon_cmd
--
	.name			= "traceon",
	.func			= ftrace_trace_onoff_callback,
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>8080</x>
      <y>3984</y>
      <w>344</w>
      <h>64</h>
    </coordinates>
    <panel_attributes>static struct ftrace_func_command ftrace_stacktrace_cmd
--
	.name			= "stacktrace",
	.func			= ftrace_stacktrace_callback,</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>8080</x>
      <y>4064</y>
      <w>336</w>
      <h>64</h>
    </coordinates>
    <panel_attributes>static struct ftrace_func_command ftrace_dump_cmd
--
	.name			= "dump",
	.func			= ftrace_dump_callback,

</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7512</x>
      <y>4000</y>
      <w>168</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7912</x>
      <y>4000</y>
      <w>184</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>210.0;10.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7912</x>
      <y>4080</y>
      <w>184</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>210.0;10.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>7584</x>
      <y>4216</y>
      <w>360</w>
      <h>56</h>
    </coordinates>
    <panel_attributes>static struct ftrace_func_command ftrace_cpudump_cmd
--
	.name			= "cpudump",
	.func			= ftrace_cpudump_callback,</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7744</x>
      <y>4088</y>
      <w>24</w>
      <h>144</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;160.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>7616</x>
      <y>4448</y>
      <w>240</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>static LIST_HEAD(ftrace_commands);
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7744</x>
      <y>4264</y>
      <w>24</w>
      <h>200</h>
    </coordinates>
    <panel_attributes>lt=&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;230.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7936</x>
      <y>4120</y>
      <w>328</w>
      <h>144</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;.</panel_attributes>
    <additional_attributes>390.0;10.0;390.0;160.0;10.0;160.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7344</x>
      <y>3920</y>
      <w>928</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=&lt;.</panel_attributes>
    <additional_attributes>10.0;80.0;10.0;10.0;1140.0;10.0;1140.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7344</x>
      <y>4032</y>
      <w>24</w>
      <h>48</h>
    </coordinates>
    <panel_attributes>lt=&lt;.</panel_attributes>
    <additional_attributes>10.0;40.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>8248</x>
      <y>4040</y>
      <w>24</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lt=&lt;.</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7344</x>
      <y>4120</y>
      <w>288</w>
      <h>360</h>
    </coordinates>
    <panel_attributes>lt=&lt;.</panel_attributes>
    <additional_attributes>340.0;430.0;10.0;430.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>8376</x>
      <y>1504</y>
      <w>304</w>
      <h>120</h>
    </coordinates>
    <panel_attributes>struct ftrace_func_probe
--
	struct ftrace_probe_ops	*probe_ops;
	struct ftrace_ops	ops;
	struct trace_array	*tr;
	struct list_head	list;
	void			*data;
	int			ref;
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>8720</x>
      <y>1520</y>
      <w>296</w>
      <h>240</h>
    </coordinates>
    <panel_attributes>struct ftrace_probe_ops
--
	void			(*func)(unsigned long ip,
					unsigned long parent_ip,
					struct trace_array *tr,
					struct ftrace_probe_ops *ops,
					void *data);
	int			(*init)(struct ftrace_probe_ops *ops,
					struct trace_array *tr,
					unsigned long ip, void *init_data,
					void **data);
	void			(*free)(struct ftrace_probe_ops *ops,
					struct trace_array *tr,
					unsigned long ip, void *data);
	int			(*print)(struct seq_file *m,
					 unsigned long ip,
					 struct ftrace_probe_ops *ops,
					 void *data);</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>8672</x>
      <y>1520</y>
      <w>64</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>7256</x>
      <y>3288</y>
      <w>272</w>
      <h>88</h>
    </coordinates>
    <panel_attributes>struct trace_event
--
	struct hlist_node		node;
	struct list_head		list;
	int				type;
	struct trace_event_functions	*funcs;
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7392</x>
      <y>3200</y>
      <w>24</w>
      <h>104</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>8344</x>
      <y>544</y>
      <w>224</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>LIST_HEAD(ftrace_trace_arrays);
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>8536</x>
      <y>464</y>
      <w>232</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>static struct trace_array xxx_trace;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>8416</x>
      <y>568</y>
      <w>416</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=&lt;-</panel_attributes>
    <additional_attributes>500.0;20.0;500.0;80.0;10.0;80.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>8416</x>
      <y>472</y>
      <w>136</w>
      <h>88</h>
    </coordinates>
    <panel_attributes>lt=&lt;.</panel_attributes>
    <additional_attributes>10.0;90.0;10.0;10.0;150.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>8760</x>
      <y>472</y>
      <w>120</w>
      <h>104</h>
    </coordinates>
    <panel_attributes>lt=&lt;.</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;10.0;130.0;110.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7584</x>
      <y>1040</y>
      <w>2104</w>
      <h>1856</h>
    </coordinates>
    <panel_attributes>lt=&lt;.
lw=4</panel_attributes>
    <additional_attributes>10.0;2300.0;2610.0;2280.0;2580.0;10.0;2470.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>6200</x>
      <y>3496</y>
      <w>312</w>
      <h>88</h>
    </coordinates>
    <panel_attributes>struct trace_event_raw_##name
--
        struct   trace_entry  ent;               
        tstruct                         
        char            __data[0];                         </panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>6576</x>
      <y>3536</y>
      <w>272</w>
      <h>48</h>
    </coordinates>
    <panel_attributes>struct trace_event_data_offsets_##call
--
        tstruct; </panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>6840</x>
      <y>3344</y>
      <w>264</w>
      <h>88</h>
    </coordinates>
    <panel_attributes>struct trace_event_functions
--
	trace_print_func	trace;
	trace_print_func	raw;
	trace_print_func	hex;
	trace_print_func	binary;

</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>5952</x>
      <y>2784</y>
      <w>376</w>
      <h>384</h>
    </coordinates>
    <panel_attributes>struct trace_event_file
--
	struct list_head		list;
	struct trace_event_call		*event_call;
	struct event_filter __rcu	*filter;
	struct dentry			*dir;
	struct trace_array		*tr;
	struct trace_subsystem_dir	*system;
	struct list_head		triggers;

	/*
	 * 32 bit flags:
	 *   bit 0:		enabled
	 *   bit 1:		enabled cmd record
	 *   bit 2:		enable/disable with the soft disable bit
	 *   bit 3:		soft disabled
	 *   bit 4:		trigger enabled
	 *
	 * Note: The bits must be set atomically to prevent races
	 * from other writers. Reads of flags do not need to be in
	 * sync as they occur in critical sections. But the way flags
	 * is currently used, these changes do not affect the code
	 * except that when a change is made, it may have a slight
	 * delay in propagating the changes to other CPUs due to
	 * caching and such. Which is mostly OK ;-)
	 */
	unsigned long		flags;
	atomic_t		sm_ref;	/* soft-mode reference counter */
	atomic_t		tm_ref;	/* trigger-mode reference counter */

</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>6320</x>
      <y>2848</y>
      <w>936</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;1150.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>6800</x>
      <y>1488</y>
      <w>24</w>
      <h>152</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;170.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>6872</x>
      <y>1048</y>
      <w>2384</w>
      <h>232</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-
lw=3</panel_attributes>
    <additional_attributes>2960.0;10.0;10.0;10.0;10.0;270.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>5896</x>
      <y>1272</y>
      <w>464</w>
      <h>56</h>
    </coordinates>
    <panel_attributes>typedef void (*ftrace_func_t)(unsigned long ip, unsigned long parent_ip,
			      struct ftrace_ops *op, struct pt_regs *regs);
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>6352</x>
      <y>1280</y>
      <w>400</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-
lw=2</panel_attributes>
    <additional_attributes>480.0;10.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>6104</x>
      <y>832</y>
      <w>1880</w>
      <h>456</h>
    </coordinates>
    <panel_attributes>lt=&lt;-
lw=4</panel_attributes>
    <additional_attributes>2330.0;10.0;2330.0;250.0;10.0;250.0;10.0;550.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>6912</x>
      <y>1544</y>
      <w>216</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>static struct ftrace_ops xxx_ops;
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>6824</x>
      <y>1640</y>
      <w>576</w>
      <h>56</h>
    </coordinates>
    <panel_attributes>lt=&lt;.</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0;700.0;50.0;700.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>6824</x>
      <y>1544</y>
      <w>104</w>
      <h>96</h>
    </coordinates>
    <panel_attributes>lt=&lt;.</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7120</x>
      <y>1544</y>
      <w>280</w>
      <h>96</h>
    </coordinates>
    <panel_attributes>lt=&lt;.</panel_attributes>
    <additional_attributes>330.0;100.0;330.0;10.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>8504</x>
      <y>1128</y>
      <w>744</w>
      <h>392</h>
    </coordinates>
    <panel_attributes>lt=&lt;.
lw=4</panel_attributes>
    <additional_attributes>10.0;470.0;10.0;10.0;910.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>8416</x>
      <y>1896</y>
      <w>200</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>struct ftrace_func_probe</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>8496</x>
      <y>1616</y>
      <w>24</w>
      <h>296</h>
    </coordinates>
    <panel_attributes>lt=&lt;.
lw=4</panel_attributes>
    <additional_attributes>10.0;350.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>8320</x>
      <y>1112</y>
      <w>936</w>
      <h>920</h>
    </coordinates>
    <panel_attributes>lt=&lt;.
lw=4</panel_attributes>
    <additional_attributes>1150.0;20.0;10.0;10.0;10.0;1130.0;230.0;1130.0;230.0;1010.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7096</x>
      <y>3344</y>
      <w>176</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>7864</x>
      <y>3344</y>
      <w>448</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>static struct hlist_head event_hash[EVENT_HASHSIZE] __read_mostly;
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7520</x>
      <y>3352</y>
      <w>360</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>430.0;10.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLNote</id>
    <coordinates>
      <x>7896</x>
      <y>3208</y>
      <w>112</w>
      <h>56</h>
    </coordinates>
    <panel_attributes>Note..
trace event使用 type
作为hash值，存入到
event_hash.</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7952</x>
      <y>3256</y>
      <w>24</w>
      <h>104</h>
    </coordinates>
    <panel_attributes>lt=&lt;-</panel_attributes>
    <additional_attributes>10.0;110.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>3144</x>
      <y>4904</y>
      <w>240</w>
      <h>56</h>
    </coordinates>
    <panel_attributes>struct idr
--
	struct radix_tree_root	idr_rt;
	unsigned int		idr_next;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>3152</x>
      <y>5064</y>
      <w>208</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>static struct idr pmu_idr;
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3240</x>
      <y>4952</y>
      <w>24</w>
      <h>128</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>3144</x>
      <y>5232</y>
      <w>424</w>
      <h>352</h>
    </coordinates>
    <panel_attributes>struct srcu_struct
--
	struct srcu_node node[NUM_RCU_NODES];	/* Combining tree. */
	struct srcu_node *level[RCU_NUM_LVLS + 1];
						/* First node at each level. */
	struct mutex srcu_cb_mutex;		/* Serialize CB preparation. */
	raw_spinlock_t __private lock;		/* Protect counters */
	struct mutex srcu_gp_mutex;		/* Serialize GP work. */
	unsigned int srcu_idx;			/* Current rdr array element. */
	unsigned long srcu_gp_seq;		/* Grace-period seq #. */
	unsigned long srcu_gp_seq_needed;	/* Latest gp_seq needed. */
	unsigned long srcu_gp_seq_needed_exp;	/* Furthest future exp GP. */
	unsigned long srcu_last_gp_end;		/* Last GP end timestamp (ns) */
	struct srcu_data __percpu *sda;		/* Per-CPU srcu_data array. */
	unsigned long srcu_barrier_seq;		/* srcu_barrier seq #. */
	struct mutex srcu_barrier_mutex;	/* Serialize barrier ops. */
	struct completion srcu_barrier_completion;
						/* Awaken barrier rq at end. */
	atomic_t srcu_barrier_cpu_cnt;		/* # CPUs not yet posting a */
						/*  callback for the barrier */
						/*  operation. */
	struct delayed_work work;
#ifdef CONFIG_DEBUG_LOCK_ALLOC
	struct lockdep_map dep_map;
#endif /* #ifdef CONFIG_DEBUG_LOCK_ALLOC */
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>3176</x>
      <y>5768</y>
      <w>320</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>static struct srcu_struct pmus_srcu;
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3328</x>
      <y>5576</y>
      <w>24</w>
      <h>208</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;240.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>816</x>
      <y>1304</y>
      <w>680</w>
      <h>2688</h>
    </coordinates>
    <panel_attributes>struct pmu
--
	struct list_head		entry;

	struct module			*module;
	struct device			*dev;
	const struct attribute_group	**attr_groups;
	const char			*name;
	int				type;

	/*
	 * various common per-pmu feature flags
	 */
	int				capabilities;

	int * __percpu			pmu_disable_count;
	struct perf_cpu_context * __percpu pmu_cpu_context;
	atomic_t			exclusive_cnt; /* &lt; 0: cpu; &gt; 0: tsk */
	int				task_ctx_nr;
	int				hrtimer_interval_ms;

	/* number of address filters this PMU can do */
	unsigned int			nr_addr_filters;

	/*
	 * Fully disable/enable this PMU, can be used to protect from the PMI
	 * as well as for lazy/batch writing of the MSRs.
	 */
	void (*pmu_enable)		(struct pmu *pmu); /* optional */
	void (*pmu_disable)		(struct pmu *pmu); /* optional */

	/*
	 * Try and initialize the event for this PMU.
	 *
	 * Returns:
	 *  -ENOENT	-- @event is not for this PMU
	 *
	 *  -ENODEV	-- @event is for this PMU but PMU not present
	 *  -EBUSY	-- @event is for this PMU but PMU temporarily unavailable
	 *  -EINVAL	-- @event is for this PMU but @event is not valid
	 *  -EOPNOTSUPP -- @event is for this PMU, @event is valid, but not supported
	 *  -EACCESS	-- @event is for this PMU, @event is valid, but no privilidges
	 *
	 *  0		-- @event is for this PMU and valid
	 *
	 * Other error return values are allowed.
	 */
	int (*event_init)		(struct perf_event *event);

	/*
	 * Notification that the event was mapped or unmapped.  Called
	 * in the context of the mapping task.
	 */
	void (*event_mapped)		(struct perf_event *event, struct mm_struct *mm); /* optional */
	void (*event_unmapped)		(struct perf_event *event, struct mm_struct *mm); /* optional */

	/*
	 * Flags for -&gt;add()/-&gt;del()/ -&gt;start()/-&gt;stop(). There are
	 * matching hw_perf_event::state flags.
	 */
#define PERF_EF_START	0x01		/* start the counter when adding    */
#define PERF_EF_RELOAD	0x02		/* reload the counter when starting */
#define PERF_EF_UPDATE	0x04		/* update the counter when stopping */

	/*
	 * Adds/Removes a counter to/from the PMU, can be done inside a
	 * transaction, see the -&gt;*_txn() methods.
	 *
	 * The add/del callbacks will reserve all hardware resources required
	 * to service the event, this includes any counter constraint
	 * scheduling etc.
	 *
	 * Called with IRQs disabled and the PMU disabled on the CPU the event
	 * is on.
	 *
	 * -&gt;add() called without PERF_EF_START should result in the same state
	 *  as -&gt;add() followed by -&gt;stop().
	 *
	 * -&gt;del() must always PERF_EF_UPDATE stop an event. If it calls
	 *  -&gt;stop() that must deal with already being stopped without
	 *  PERF_EF_UPDATE.
	 */
	int  (*add)			(struct perf_event *event, int flags);
	void (*del)			(struct perf_event *event, int flags);

	/*
	 * Starts/Stops a counter present on the PMU.
	 *
	 * The PMI handler should stop the counter when perf_event_overflow()
	 * returns !0. -&gt;start() will be used to continue.
	 *
	 * Also used to change the sample period.
	 *
	 * Called with IRQs disabled and the PMU disabled on the CPU the event
	 * is on -- will be called from NMI context with the PMU generates
	 * NMIs.
	 *
	 * -&gt;stop() with PERF_EF_UPDATE will read the counter and update
	 *  period/count values like -&gt;read() would.
	 *
	 * -&gt;start() with PERF_EF_RELOAD will reprogram the the counter
	 *  value, must be preceded by a -&gt;stop() with PERF_EF_UPDATE.
	 */
	void (*start)			(struct perf_event *event, int flags);
	void (*stop)			(struct perf_event *event, int flags);

	/*
	 * Updates the counter value of the event.
	 *
	 * For sampling capable PMUs this will also update the software period
	 * hw_perf_event::period_left field.
	 */
	void (*read)			(struct perf_event *event);

	/*
	 * Group events scheduling is treated as a transaction, add
	 * group events as a whole and perform one schedulability test.
	 * If the test fails, roll back the whole group
	 *
	 * Start the transaction, after this -&gt;add() doesn't need to
	 * do schedulability tests.
	 *
	 * Optional.
	 */
	void (*start_txn)		(struct pmu *pmu, unsigned int txn_flags);
	/*
	 * If -&gt;start_txn() disabled the -&gt;add() schedulability test
	 * then -&gt;commit_txn() is required to perform one. On success
	 * the transaction is closed. On error the transaction is kept
	 * open until -&gt;cancel_txn() is called.
	 *
	 * Optional.
	 */
	int  (*commit_txn)		(struct pmu *pmu);
	/*
	 * Will cancel the transaction, assumes -&gt;del() is called
	 * for each successful -&gt;add() during the transaction.
	 *
	 * Optional.
	 */
	void (*cancel_txn)		(struct pmu *pmu);

	/*
	 * Will return the value for perf_event_mmap_page::index for this event,
	 * if no implementation is provided it will default to: event-&gt;hw.idx + 1.
	 */
	int (*event_idx)		(struct perf_event *event); /*optional */

	/*
	 * context-switches callback
	 */
	void (*sched_task)		(struct perf_event_context *ctx,
					bool sched_in);
	/*
	 * PMU specific data size
	 */
	size_t				task_ctx_size;


	/*
	 * Set up pmu-private data structures for an AUX area
	 */
	void *(*setup_aux)		(int cpu, void **pages,
					 int nr_pages, bool overwrite);
					/* optional */

	/*
	 * Free pmu-private AUX data structures
	 */
	void (*free_aux)		(void *aux); /* optional */

	/*
	 * Validate address range filters: make sure the HW supports the
	 * requested configuration and number of filters; return 0 if the
	 * supplied filters are valid, -errno otherwise.
	 *
	 * Runs in the context of the ioctl()ing process and is not serialized
	 * with the rest of the PMU callbacks.
	 */
	int (*addr_filters_validate)	(struct list_head *filters);
					/* optional */

	/*
	 * Synchronize address range filter configuration:
	 * translate hw-agnostic filters into hardware configuration in
	 * event::hw::addr_filters.
	 *
	 * Runs as a part of filter sync sequence that is done in -&gt;start()
	 * callback by calling perf_event_addr_filters_sync().
	 *
	 * May (and should) traverse event::addr_filters::list, for which its
	 * caller provides necessary serialization.
	 */
	void (*addr_filters_sync)	(struct perf_event *event);
					/* optional */

	/*
	 * Filter events for PMU-specific reasons.
	 */
	int (*filter_match)		(struct perf_event *event); /* optional */

	/*
	 * Check period value for PERF_EVENT_IOC_PERIOD ioctl.
	 */
	int (*check_period)		(struct perf_event *event, u64 value); /* optional */

</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>736</x>
      <y>4144</y>
      <w>240</w>
      <h>176</h>
    </coordinates>
    <panel_attributes>static struct pmu perf_swevent
--
	.task_ctx_nr	= perf_sw_context,

	.capabilities	= PERF_PMU_CAP_NO_NMI,

	.event_init	= perf_swevent_init,
	.add		= perf_swevent_add,
	.del		= perf_swevent_del,
	.start		= perf_swevent_start,
	.stop		= perf_swevent_stop,
	.read		= perf_swevent_read,
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>840</x>
      <y>3984</y>
      <w>24</w>
      <h>176</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;200.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1000</x>
      <y>4144</y>
      <w>256</w>
      <h>192</h>
    </coordinates>
    <panel_attributes>static struct pmu perf_cpu_clock
--
	.task_ctx_nr	= perf_sw_context,

	.capabilities	= PERF_PMU_CAP_NO_NMI,

	.event_init	= cpu_clock_event_init,
	.add		= cpu_clock_event_add,
	.del		= cpu_clock_event_del,
	.start		= cpu_clock_event_start,
	.stop		= cpu_clock_event_stop,
	.read		= cpu_clock_event_read,
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1104</x>
      <y>3984</y>
      <w>24</w>
      <h>176</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;200.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1304</x>
      <y>4152</y>
      <w>264</w>
      <h>184</h>
    </coordinates>
    <panel_attributes>static struct pmu perf_task_clock
--
	.task_ctx_nr	= perf_sw_context,

	.capabilities	= PERF_PMU_CAP_NO_NMI,

	.event_init	= task_clock_event_init,
	.add		= task_clock_event_add,
	.del		= task_clock_event_del,
	.start		= task_clock_event_start,
	.stop		= task_clock_event_stop,
	.read		= task_clock_event_read,
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1376</x>
      <y>3984</y>
      <w>24</w>
      <h>184</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;210.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1232</x>
      <y>4944</y>
      <w>256</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>struct notifier_block
--
	notifier_fn_t notifier_call;
	struct notifier_block __rcu *next;
	int priority;

</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1192</x>
      <y>5168</y>
      <w>304</w>
      <h>72</h>
    </coordinates>
    <panel_attributes>static struct notifier_block perf_reboot_notifier
--
	.notifier_call = perf_reboot,
	.priority = INT_MIN,
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1336</x>
      <y>5016</y>
      <w>24</w>
      <h>168</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1248</x>
      <y>5480</y>
      <w>256</w>
      <h>64</h>
    </coordinates>
    <panel_attributes>static struct bus_type pmu_bus
--
	.name		= "event_source",
	.dev_groups	= pmu_dev_groups,

</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1304</x>
      <y>5392</y>
      <w>136</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>struct bus_type</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1344</x>
      <y>5408</y>
      <w>24</w>
      <h>88</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>0</x>
      <y>4240</y>
      <w>240</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>static LIST_HEAD(pmus);
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>592</x>
      <y>4216</y>
      <w>152</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;.</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>968</x>
      <y>4224</y>
      <w>48</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;.</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1248</x>
      <y>4240</y>
      <w>72</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;.</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>80</x>
      <y>4264</y>
      <w>1864</w>
      <h>136</h>
    </coordinates>
    <panel_attributes>lt=&lt;.</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;150.0;2310.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>2264</x>
      <y>1304</y>
      <w>456</w>
      <h>736</h>
    </coordinates>
    <panel_attributes>struct perf_event_context
--
	struct pmu			*pmu;
	/*
	 * Protect the states of the events in the list,
	 * nr_active, and the list:
	 */
	raw_spinlock_t			lock;
	/*
	 * Protect the list of events.  Locking either mutex or lock
	 * is sufficient to ensure the list doesn't change; to change
	 * the list you need to lock both the mutex and the spinlock.
	 */
	struct mutex			mutex;

	struct list_head		active_ctx_list;
	struct list_head		pinned_groups;
	struct list_head		flexible_groups;
	struct list_head		event_list;
	int				nr_events;
	int				nr_active;
	int				is_active;
	int				nr_stat;
	int				nr_freq;
	int				rotate_disable;
	atomic_t			refcount;
	struct task_struct		*task;

	/*
	 * Context clock, runs when context enabled.
	 */
	u64				time;
	u64				timestamp;

	/*
	 * These fields let us detect when two contexts have both
	 * been cloned (inherited) from a common ancestor.
	 */
	struct perf_event_context	*parent_ctx;
	u64				parent_gen;
	u64				generation;
	int				pin_count;
#ifdef CONFIG_CGROUP_PERF
	int				nr_cgroups;	 /* cgroup evts */
#endif
	void				*task_ctx_data; /* pmu specific data */
	struct rcu_head			rcu_head;

</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1488</x>
      <y>1304</y>
      <w>792</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>970.0;10.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>3088</x>
      <y>1368</y>
      <w>432</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>struct task_struct
--
	struct perf_event_context	*perf_event_ctxp[perf_nr_task_contexts];
	struct mutex			perf_event_mutex;
	struct list_head		perf_event_list;
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2712</x>
      <y>1368</y>
      <w>392</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;470.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1728</x>
      <y>1480</y>
      <w>272</w>
      <h>280</h>
    </coordinates>
    <panel_attributes>struct perf_cpu_context
--
	struct perf_event_context	ctx;
	struct perf_event_context	*task_ctx;
	int				active_oncpu;
	int				exclusive;

	raw_spinlock_t			hrtimer_lock;
	struct hrtimer			hrtimer;
	ktime_t				hrtimer_interval;
	unsigned int			hrtimer_active;

#ifdef CONFIG_CGROUP_PERF
	struct perf_cgroup		*cgrp;
	struct list_head		cgrp_cpuctx_entry;
#endif

	struct list_head		sched_cb_entry;
	int				sched_cb_usage;

	int				online;</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1992</x>
      <y>1504</y>
      <w>288</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>3024</x>
      <y>1904</y>
      <w>448</w>
      <h>2192</h>
    </coordinates>
    <panel_attributes>struct perf_event
--
#ifdef CONFIG_PERF_EVENTS
	/*
	 * entry onto perf_event_context::event_list;
	 *   modifications require ctx-&gt;lock
	 *   RCU safe iterations.
	 */
	struct list_head		event_entry;

	/*
	 * XXX: group_entry and sibling_list should be mutually exclusive;
	 * either you're a sibling on a group, or you're the group leader.
	 * Rework the code to always use the same list element.
	 *
	 * Locked for modification by both ctx-&gt;mutex and ctx-&gt;lock; holding
	 * either sufficies for read.
	 */
	struct list_head		group_entry;
	struct list_head		sibling_list;

	/*
	 * We need storage to track the entries in perf_pmu_migrate_context; we
	 * cannot use the event_entry because of RCU and we want to keep the
	 * group in tact which avoids us using the other two entries.
	 */
	struct list_head		migrate_entry;

	struct hlist_node		hlist_entry;
	struct list_head		active_entry;
	int				nr_siblings;

	/* Not serialized. Only written during event initialization. */
	int				event_caps;
	/* The cumulative AND of all event_caps for events in this group. */
	int				group_caps;

	struct perf_event		*group_leader;
	struct pmu			*pmu;
	void				*pmu_private;

	enum perf_event_active_state	state;
	unsigned int			attach_state;
	local64_t			count;
	atomic64_t			child_count;

	/*
	 * These are the total time in nanoseconds that the event
	 * has been enabled (i.e. eligible to run, and the task has
	 * been scheduled in, if this is a per-task event)
	 * and running (scheduled onto the CPU), respectively.
	 *
	 * They are computed from tstamp_enabled, tstamp_running and
	 * tstamp_stopped when the event is in INACTIVE or ACTIVE state.
	 */
	u64				total_time_enabled;
	u64				total_time_running;

	/*
	 * These are timestamps used for computing total_time_enabled
	 * and total_time_running when the event is in INACTIVE or
	 * ACTIVE state, measured in nanoseconds from an arbitrary point
	 * in time.
	 * tstamp_enabled: the notional time when the event was enabled
	 * tstamp_running: the notional time when the event was scheduled on
	 * tstamp_stopped: in INACTIVE state, the notional time when the
	 *	event was scheduled off.
	 */
	u64				tstamp_enabled;
	u64				tstamp_running;
	u64				tstamp_stopped;

	/*
	 * timestamp shadows the actual context timing but it can
	 * be safely used in NMI interrupt context. It reflects the
	 * context time as it was when the event was last scheduled in.
	 *
	 * ctx_time already accounts for ctx-&gt;timestamp. Therefore to
	 * compute ctx_time for a sample, simply add perf_clock().
	 */
	u64				shadow_ctx_time;

	struct perf_event_attr		attr;
	u16				header_size;
	u16				id_header_size;
	u16				read_size;
	struct hw_perf_event		hw;

	struct perf_event_context	*ctx;
	atomic_long_t			refcount;

	/*
	 * These accumulate total time (in nanoseconds) that children
	 * events have been enabled and running, respectively.
	 */
	atomic64_t			child_total_time_enabled;
	atomic64_t			child_total_time_running;

	/*
	 * Protect attach/detach and child_list:
	 */
	struct mutex			child_mutex;
	struct list_head		child_list;
	struct perf_event		*parent;

	int				oncpu;
	int				cpu;

	struct list_head		owner_entry;
	struct task_struct		*owner;

	/* mmap bits */
	struct mutex			mmap_mutex;
	atomic_t			mmap_count;

	struct ring_buffer		*rb;
	struct list_head		rb_entry;
	unsigned long			rcu_batches;
	int				rcu_pending;

	/* poll related */
	wait_queue_head_t		waitq;
	struct fasync_struct		*fasync;

	/* delayed work for NMIs and such */
	int				pending_wakeup;
	int				pending_kill;
	int				pending_disable;
	struct irq_work			pending;

	atomic_t			event_limit;

	/* address range filters */
	struct perf_addr_filters_head	addr_filters;
	/* vma address array for file-based filders */
	unsigned long			*addr_filters_offs;
	unsigned long			addr_filters_gen;

	void (*destroy)(struct perf_event *);
	struct rcu_head			rcu_head;

	struct pid_namespace		*ns;
	u64				id;

	u64				(*clock)(void);
	perf_overflow_handler_t		overflow_handler;
	void				*overflow_handler_context;
#ifdef CONFIG_BPF_SYSCALL
	perf_overflow_handler_t		orig_overflow_handler;
	struct bpf_prog			*prog;
#endif

#ifdef CONFIG_EVENT_TRACING
	struct trace_event_call		*tp_event;
	struct event_filter		*filter;
#ifdef CONFIG_FUNCTION_TRACER
	struct ftrace_ops               ftrace_ops;
#endif
#endif

#ifdef CONFIG_CGROUP_PERF
	struct perf_cgroup		*cgrp; /* cgroup event is attach to */
	int				cgrp_defer_enabled;
#endif

	struct list_head		sb_list;
#endif /* CONFIG_PERF_EVENTS */
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2712</x>
      <y>1904</y>
      <w>328</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;.</panel_attributes>
    <additional_attributes>390.0;10.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1488</x>
      <y>1480</y>
      <w>256</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2712</x>
      <y>1384</y>
      <w>392</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>470.0;10.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>3680</x>
      <y>1904</y>
      <w>448</w>
      <h>2192</h>
    </coordinates>
    <panel_attributes>struct perf_event
--
#ifdef CONFIG_PERF_EVENTS
	/*
	 * entry onto perf_event_context::event_list;
	 *   modifications require ctx-&gt;lock
	 *   RCU safe iterations.
	 */
	struct list_head		event_entry;

	/*
	 * XXX: group_entry and sibling_list should be mutually exclusive;
	 * either you're a sibling on a group, or you're the group leader.
	 * Rework the code to always use the same list element.
	 *
	 * Locked for modification by both ctx-&gt;mutex and ctx-&gt;lock; holding
	 * either sufficies for read.
	 */
	struct list_head		group_entry;
	struct list_head		sibling_list;

	/*
	 * We need storage to track the entries in perf_pmu_migrate_context; we
	 * cannot use the event_entry because of RCU and we want to keep the
	 * group in tact which avoids us using the other two entries.
	 */
	struct list_head		migrate_entry;

	struct hlist_node		hlist_entry;
	struct list_head		active_entry;
	int				nr_siblings;

	/* Not serialized. Only written during event initialization. */
	int				event_caps;
	/* The cumulative AND of all event_caps for events in this group. */
	int				group_caps;

	struct perf_event		*group_leader;
	struct pmu			*pmu;
	void				*pmu_private;

	enum perf_event_active_state	state;
	unsigned int			attach_state;
	local64_t			count;
	atomic64_t			child_count;

	/*
	 * These are the total time in nanoseconds that the event
	 * has been enabled (i.e. eligible to run, and the task has
	 * been scheduled in, if this is a per-task event)
	 * and running (scheduled onto the CPU), respectively.
	 *
	 * They are computed from tstamp_enabled, tstamp_running and
	 * tstamp_stopped when the event is in INACTIVE or ACTIVE state.
	 */
	u64				total_time_enabled;
	u64				total_time_running;

	/*
	 * These are timestamps used for computing total_time_enabled
	 * and total_time_running when the event is in INACTIVE or
	 * ACTIVE state, measured in nanoseconds from an arbitrary point
	 * in time.
	 * tstamp_enabled: the notional time when the event was enabled
	 * tstamp_running: the notional time when the event was scheduled on
	 * tstamp_stopped: in INACTIVE state, the notional time when the
	 *	event was scheduled off.
	 */
	u64				tstamp_enabled;
	u64				tstamp_running;
	u64				tstamp_stopped;

	/*
	 * timestamp shadows the actual context timing but it can
	 * be safely used in NMI interrupt context. It reflects the
	 * context time as it was when the event was last scheduled in.
	 *
	 * ctx_time already accounts for ctx-&gt;timestamp. Therefore to
	 * compute ctx_time for a sample, simply add perf_clock().
	 */
	u64				shadow_ctx_time;

	struct perf_event_attr		attr;
	u16				header_size;
	u16				id_header_size;
	u16				read_size;
	struct hw_perf_event		hw;

	struct perf_event_context	*ctx;
	atomic_long_t			refcount;

	/*
	 * These accumulate total time (in nanoseconds) that children
	 * events have been enabled and running, respectively.
	 */
	atomic64_t			child_total_time_enabled;
	atomic64_t			child_total_time_running;

	/*
	 * Protect attach/detach and child_list:
	 */
	struct mutex			child_mutex;
	struct list_head		child_list;
	struct perf_event		*parent;

	int				oncpu;
	int				cpu;

	struct list_head		owner_entry;
	struct task_struct		*owner;

	/* mmap bits */
	struct mutex			mmap_mutex;
	atomic_t			mmap_count;

	struct ring_buffer		*rb;
	struct list_head		rb_entry;
	unsigned long			rcu_batches;
	int				rcu_pending;

	/* poll related */
	wait_queue_head_t		waitq;
	struct fasync_struct		*fasync;

	/* delayed work for NMIs and such */
	int				pending_wakeup;
	int				pending_kill;
	int				pending_disable;
	struct irq_work			pending;

	atomic_t			event_limit;

	/* address range filters */
	struct perf_addr_filters_head	addr_filters;
	/* vma address array for file-based filders */
	unsigned long			*addr_filters_offs;
	unsigned long			addr_filters_gen;

	void (*destroy)(struct perf_event *);
	struct rcu_head			rcu_head;

	struct pid_namespace		*ns;
	u64				id;

	u64				(*clock)(void);
	perf_overflow_handler_t		overflow_handler;
	void				*overflow_handler_context;
#ifdef CONFIG_BPF_SYSCALL
	perf_overflow_handler_t		orig_overflow_handler;
	struct bpf_prog			*prog;
#endif

#ifdef CONFIG_EVENT_TRACING
	struct trace_event_call		*tp_event;
	struct event_filter		*filter;
#ifdef CONFIG_FUNCTION_TRACER
	struct ftrace_ops               ftrace_ops;
#endif
#endif

#ifdef CONFIG_CGROUP_PERF
	struct perf_cgroup		*cgrp; /* cgroup event is attach to */
	int				cgrp_defer_enabled;
#endif

	struct list_head		sb_list;
#endif /* CONFIG_PERF_EVENTS */
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>3568</x>
      <y>2160</y>
      <w>48</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>`...</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3464</x>
      <y>2168</y>
      <w>120</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;.</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3608</x>
      <y>2168</y>
      <w>88</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;.</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2712</x>
      <y>1688</y>
      <w>1576</w>
      <h>504</h>
    </coordinates>
    <panel_attributes>lt=&lt;.</panel_attributes>
    <additional_attributes>10.0;20.0;1940.0;10.0;1950.0;610.0;1770.0;610.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>4360</x>
      <y>2648</y>
      <w>232</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>	struct ring_buffer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4120</x>
      <y>2648</y>
      <w>256</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>4360</x>
      <y>2400</y>
      <w>264</w>
      <h>128</h>
    </coordinates>
    <panel_attributes>enum perf_event_active_state
--
	PERF_EVENT_STATE_DEAD		= -4,
	PERF_EVENT_STATE_EXIT		= -3,
	PERF_EVENT_STATE_ERROR		= -2,
	PERF_EVENT_STATE_OFF		= -1,
	PERF_EVENT_STATE_INACTIVE	=  0,
	PERF_EVENT_STATE_ACTIVE		=  1,
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4120</x>
      <y>2400</y>
      <w>256</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>2096</x>
      <y>5056</y>
      <w>328</w>
      <h>128</h>
    </coordinates>
    <panel_attributes>struct swevent_htable
--
	struct swevent_hlist		*swevent_hlist;
	struct mutex			hlist_mutex;
	int				hlist_refcount;

	/* Recursion avoidance in each contexts */
	int				recursion[PERF_NR_CONTEXTS];
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>2552</x>
      <y>5112</y>
      <w>312</w>
      <h>56</h>
    </coordinates>
    <panel_attributes>struct swevent_hlist
--
	struct hlist_head		heads[SWEVENT_HLIST_SIZE];
	struct rcu_head			rcu_head;

</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2416</x>
      <y>5112</y>
      <w>152</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>2072</x>
      <y>5288</y>
      <w>384</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>static DEFINE_PER_CPU(struct swevent_htable, swevent_htable);
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2256</x>
      <y>5176</y>
      <w>24</w>
      <h>128</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;140.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>816</x>
      <y>4592</y>
      <w>768</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>static struct idr pmu_idr;
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>832</x>
      <y>4312</y>
      <w>24</w>
      <h>296</h>
    </coordinates>
    <panel_attributes>lt=&lt;.</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;350.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1152</x>
      <y>4328</y>
      <w>24</w>
      <h>280</h>
    </coordinates>
    <panel_attributes>lt=&lt;.</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;330.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1480</x>
      <y>4328</y>
      <w>24</w>
      <h>280</h>
    </coordinates>
    <panel_attributes>lt=&lt;.</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;330.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>1928</x>
      <y>4152</y>
      <w>520</w>
      <h>496</h>
    </coordinates>
    <panel_attributes>struct arm_pmu
--
	struct pmu	pmu;
	cpumask_t	active_irqs;
	cpumask_t	supported_cpus;
	char		*name;
	irqreturn_t	(*handle_irq)(int irq_num, void *dev);
	void		(*enable)(struct perf_event *event);
	void		(*disable)(struct perf_event *event);
	int		(*get_event_idx)(struct pmu_hw_events *hw_events,
					 struct perf_event *event);
	void		(*clear_event_idx)(struct pmu_hw_events *hw_events,
					 struct perf_event *event);
	int		(*set_event_filter)(struct hw_perf_event *evt,
					    struct perf_event_attr *attr);
	u32		(*read_counter)(struct perf_event *event);
	void		(*write_counter)(struct perf_event *event, u32 val);
	void		(*start)(struct arm_pmu *);
	void		(*stop)(struct arm_pmu *);
	void		(*reset)(void *);
	int		(*map_event)(struct perf_event *event);
	int		(*filter_match)(struct perf_event *event);
	int		num_events;
	u64		max_period;
	bool		secure_access; /* 32-bit ARM only */
#define ARMV8_PMUV3_MAX_COMMON_EVENTS 0x40
	DECLARE_BITMAP(pmceid_bitmap, ARMV8_PMUV3_MAX_COMMON_EVENTS);
	struct platform_device	*plat_device;
	struct pmu_hw_events	__percpu *hw_events;
	struct hlist_node	node;
	struct notifier_block	cpu_pm_nb;
	/* the attr_groups array must be NULL-terminated */
	const struct attribute_group *attr_groups[ARMPMU_NR_ATTR_GROUPS + 1];

	/* Only to be used by ACPI probing code */
	unsigned long acpi_cpuid;
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1472</x>
      <y>3984</y>
      <w>744</w>
      <h>184</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0;910.0;60.0;910.0;210.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>3016</x>
      <y>4264</y>
      <w>488</w>
      <h>344</h>
    </coordinates>
    <panel_attributes>struct pmu_hw_events
--
	/*
	 * The events that are active on the PMU for the given index.
	 */
	struct perf_event	*events[ARMPMU_MAX_HWEVENTS];

	/*
	 * A 1 bit for an index indicates that the counter is being used for
	 * an event. A 0 means that the counter can be used.
	 */
	DECLARE_BITMAP(used_mask, ARMPMU_MAX_HWEVENTS);

	/*
	 * Hardware lock to serialize accesses to PMU registers. Needed for the
	 * read/modify/write sequences.
	 */
	raw_spinlock_t		pmu_lock;

	/*
	 * When using percpu IRQs, we need a percpu dev_id. Place it here as we
	 * already have to allocate this struct per cpu.
	 */
	struct arm_pmu		*percpu_pmu;

	int irq;
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2440</x>
      <y>4264</y>
      <w>592</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;720.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3240</x>
      <y>4088</y>
      <w>24</w>
      <h>192</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;220.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1560</x>
      <y>4256</y>
      <w>384</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;.</panel_attributes>
    <additional_attributes>460.0;10.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>368</x>
      <y>4160</y>
      <w>232</w>
      <h>168</h>
    </coordinates>
    <panel_attributes>static struct pmu perf_tracepoint
--
	.task_ctx_nr	= perf_sw_context,

	.event_init	= perf_tp_event_init,
	.add		= perf_trace_add,
	.del		= perf_trace_del,
	.start		= perf_swevent_start,
	.stop		= perf_swevent_stop,
	.read		= perf_swevent_read,

</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>232</x>
      <y>4240</y>
      <w>152</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;.</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1992</x>
      <y>1184</y>
      <w>1264</w>
      <h>360</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;&lt;&lt;-</panel_attributes>
    <additional_attributes>10.0;430.0;150.0;430.0;150.0;10.0;1560.0;10.0;1560.0;230.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4120</x>
      <y>3088</y>
      <w>3136</w>
      <h>232</h>
    </coordinates>
    <panel_attributes>lt=&lt;-
lw=4</panel_attributes>
    <additional_attributes>10.0;270.0;3680.0;270.0;3680.0;10.0;3900.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3600</x>
      <y>3288</y>
      <w>96</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;.
lw=4</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLClass</id>
    <coordinates>
      <x>3560</x>
      <y>3280</y>
      <w>48</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>`...</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3472</x>
      <y>3288</y>
      <w>104</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=&lt;.
lw=4</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2800</x>
      <y>3072</y>
      <w>4448</w>
      <h>232</h>
    </coordinates>
    <panel_attributes>lt=&lt;.
lw=4</panel_attributes>
    <additional_attributes>5540.0;10.0;10.0;30.0;10.0;270.0;280.0;270.0</additional_attributes>
  </element>
</diagram>
